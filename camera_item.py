'''
'''

import os
import subprocess
import hashlib
import Image

# create exiftool request string
EXIF_TOOL = "/usr/bin/exiftool"
TAGS_CLASSIFICATION = [
                'FileName',
                'Model',
                'Software',
                'DateTimeOriginal',
                'CreateDate',
                'ImageWidth',
                'ImageHeight'
                ]
TAGS_TO_GET = TAGS_CLASSIFICATION + [
                'TagsList',
                'HierarchicalSubject',
                'Subject',
                'Keywords'
                ]
EXIFTOOL_REQUEST = EXIF_TOOL + ' -s'
for tag in TAGS_TO_GET:
    EXIFTOOL_REQUEST = EXIFTOOL_REQUEST + ' -' + tag

# digital camera items
class CameraItem:
    'class that handles all kind of content (photo, video, audio) generated by a digital camera'

    # private methods
    def __init__(self, name):
        'initialize the properties of the item'
        self.name = name
        for tag in TAGS_TO_GET:
            setattr(self, tag, "")
        self.tags_file = ""
        self.content_file = ""
        self.aux_files = []
        self._content_checksum = ''
        self._thumbnail_checksum = ''

    def _check_file(self, file_path):
        'confirms that the file that wants to be added corresponds this item'
        file_item_name = os.path.splitext(file_path)[0]
        if file_item_name == self.name:
            return True
        else:
            return False

    def _get_info(self):
        'gets information of the item from the tags_file (mainly a JPEG file)'
        # get the path of the image
        image_path = ''
        for file in self._files:
            if self._is_jpeg(file):
                image_path = file
                break
        if image_path == '':
            raise RuntimeError, "missing image of item " + os.path.join(self.directory, self.name)
        # invoke 'exiftool' to get the information
        exif_tags = {}
        cmd = EXIFTOOL_REQUEST + ' "' + image_path + '"'
        output = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
        lines = output.read().splitlines()
        for line in lines:
            (tag_name, _, tag_value) = line.partition(':')
            exif_tags[tag_name.strip()] = tag_value.strip()
        for tag in TAGS_TO_GET:
            setattr(self, tag, exif_tags[tag])    

    def _get_jpeg_checksum(self, filepath):
        'calculates the SHA512 checksum of a JPEG image'
        try:
            img = Image.open(filepath)
            cksm = hashlib.sha512()
            cksm.update(img.tostring())
            checksum = cksm.digest()
        except Exception, err:
            trace_err("Error getting image from file %s: %s" % (filepath, str(err)))
        return checksum

    def _get_video_checksum(self, filepath):
        'returns the checksum of a video, using ffmpeg and md5sum'
        cmd = '/usr/bin/ffmpeg -i "' + filepath + '" -f avi - 2>/dev/null | /usr/bin/md5sum'
        output = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
        result = output.read().splitlines()[0]
        return result.split(' ')[0]

    def _get_audio_checksum(self, filepath):
        raise RuntimeError, "checksum generation for file %s is not possible, "\
            "not implemented yet" % filepath

    # class methods
    @classmethod
    def _is_jpeg(CameraItem, filepath):
        'returns True is extension corresponds to image in JPEG format, elsewhere False is returned'
        if (os.path.splitext(filepath)[1].lower() in ('.jpg', '.jpeg', '.thm', '.jpe', '.jpg_original')):
            return True
        else:
            return False

    @classmethod
    def _is_image_no_metadata(CameraItem, filepath):
        'returns True is extension corresponds to image in format without data, elsewhere False is returned'
        if (os.path.splitext(filepath)[1].lower() in ('.gif', '.png')):
            return True
        else:
            return False

    @classmethod
    def _is_raw(CameraItem, filepath):
        'returns True is extension corresponds to image in RAW format, elsewhere False is returned'
        if (os.path.splitext(filepath)[1].lower() in ('.raw', '.tif', '.rw2')):
            return True
        else:
            return False

    @classmethod
    def _is_video(CameraItem, filepath):
        'returns True is extension corresponds to video, elsewhere False is returned'
        if (os.path.splitext(filepath)[1].lower() in ('.mov', '.mpg', '.avi')):
            return True
        else:
            return False

    @classmethod
    def _is_audio(CameraItem, filepath):
        'returns True is extension corresponds to audio, elsewhere False is returned'
        if (os.path.splitext(filepath)[1].lower() in ('.wav')):
            return True
        else:
            return False

    @classmethod
    def path_to_name(CameraItem, file_path):
        'returns the item name that corresponds to a certain filename'
        if not (CameraItem._is_jpeg(file_path) or
                CameraItem._is_video(file_path) or
                CameraItem._is_raw(file_path) or
                CameraItem._is_audio(file_path) or
                CameraItem._is_image_no_metadata(file_path)):
            trace_err(file_path + " is of unknown type")
            return ''
        return os.path.splitext(file_path)[0]
    
    # public methods
    def add(self, file_path):
        'adds a file to the item'
        # check that the file belongs here
        if not self._check_file(file_path):
            raise RuntimeError, file_path + " doesn't belong to item " + self.name
        # ITEM CONTENT
        # if no files in item, get content from file
        if self.content_file == "":
            self.content_file = file_path
        else:
            # if content file is a JPEG file, non-JPEG file gives content
            if self._is_jpeg(self.content_file):
                if not self._is_jpeg(file_path):
                    self.content_file = file_path
                else:    
                    trace_err("the JPEG file %s cannot be added to " \
                        "the item %s, it already contains the JPEG file %s" % \
                        (file_path, self.name, self.tags_file))
                    return
            # if content file is already a non-JPEG file, trying to add a non-JPEG file is an error
            else:
                if not self._is_jpeg(file_path):
                    trace_err("the non-JPEG file %s cannot be added " \
                        "to the item %s, it already contains the content of " \
                        "the non-JPEG file %s" % (file_path, self.name, self.content_file))
                    return
        # ITEM TAGS
        # if JPEG file, then use its tags for the item
        if self._is_jpeg(file_path):
            if self.tags_file != "":
                raise RuntimeError, "the file %s cannot be added to the item %s, " \
                    "the file %s already contains the tags of the item" % \
                    (file_path, self.name, self.tags_file)
            else:
                self.tags_file = file_path
        # ITEM AUX FILES
        # if audio file, then save as auxiliar file
        if self._is_audio(file_path):
            self.aux_files.append(file_path)

    def _get_content_checksum(self):
        'calculates the checksum of the item content'
        if self._content_checksum == '':
            if self._is_jpeg(self.content_file):
                self._content_checksum = self._get_jpeg_checksum(self.content_file)
            if self._is_video(self.content_file):
                self._content_checksum = self._get_video_checksum(self.content_file)
            if self._content_checksum == '':
                trace_err("WARNING: checksum of " + self.content_file + " cannot be calculated")
                return ''
                if self._is_raw(self.content_file):
                    self._content_checksum = self._get_raw_checksum(self.content_file)
                if self._is_audio(self.content_file):
                    self._content_checksum = self._get_audio_checksum(self.content_file)
        return self._content_checksum

    content_checksum = property(_get_content_checksum)

    def _get_thumbnail_checksum(self):
        'calculates the checksum of the item thumbnail'
        if self.tags_file == '':
            trace_err("item "+ self.name + " with content file " + self.content_file + " doesn't have a tags_file")
            return ''
        if self._thumbnail_checksum == '':
            if self.content_file == self.tags_file:
                self._thumbnail_checksum = self._content_checksum
            else:
                trace_err("calculating checksum of thumbnail file " + self.tags_file)
                self._thumbnail_checksum = self._get_jpeg_checksum(self.tags_file)
        return self._thumbnail_checksum

    thumbnail_checksum = property(_get_thumbnail_checksum)

    def remove(self):
        'removes the item'
        raise RuntimeError, "method remove not implemented yet in the class CameraItem"
        if self.content != "":
            os.remove(self.content)
        if self.tags_file != "":
            os.remove(self.tags_file)
        if len(self.aux_files) > 0:
            for file in self.aux_files:
                os.remove(file)

    def move(self, new_dir):
        'moves the item to the directory "new_dir"'
        raise RuntimeError, "method move not implemented yet in the class CameraItem"
