#!/usr/bin/python

'''
Analyze every subdirectory recursively. For every file create an item with the name of the file without extension.
If an item with that name already exists, then consider it an item with sidecar. If item was of type JPEG and
new file is a video, change type to video and calculate checksum of video. If item was of type video and new
file is a JPEG, add JPEG tags to item. If item was of type JPEG and new file is a RAW, change type to RAW and 
calculate checksum of RAW image. If item was of type RAW and new file is a JPEG, add JPEG tags to item.
'''
import pickle
import os.path
import subprocess
import hashlib
import Image

# create exiftool request string
EXIF_TOOL = "/usr/bin/exiftool"
TAGS_TO_GET = [ 'FileName',
				'Model',
				'Software',
				'DateTimeOriginal',
				'CreateDate',
				'ImageWidth',
				'ImageHeight',
				'TagsList',
				'HierarchicalSubject',
				'Subject',
				'Keywords'
				]
EXIFTOOL_REQUEST = EXIF_TOOL + ' -s'
for tag in TAGS_TO_GET:
	EXIFTOOL_REQUEST = EXIFTOOL_REQUEST + ' -' + tag

EXTENSIONS_TO_IGNORE = ['.db', '.ini', '.info', '.zip', '.strm',
						'.pto', '.mk', '.bkc', '.log', '.jbf', '.tar']

# digital camera items
class CameraItem:
	'class that handles all kind of content (photo, video, audio) generated by a digital camera'

	# private methods
	def __init__(self, name):
		'initialize the properties of the item'
		self.name = name
		for tag in TAGS_TO_GET:
			setattr(self, tag, "")
		self.tags_file = ""
		self.content_file = ""
		self.aux_files = []

	def _check_file(self, file_path):
		'confirms that the file that wants to be added corresponds this item'
		file_item_name = os.path.splitext(file_path)[0]
		if file_item_name == self.name:
			return True
		else:
			return False

	def _get_info(self):
		'gets information of the item from the always present image'
		# get the path of the image
		image_path = ''
		for file in self._files:
			if self._is_jpeg(file):
				image_path = file
				break
		if image_path == '':
			raise RuntimeError, "missing image of item " + os.path.join(self.directory, self.name)
		# invoke 'exiftool' to get the information
		exif_tags = {}
		cmd = EXIFTOOL_REQUEST + ' "' + image_path + '"'
		output = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
		lines = output.read().splitlines()
		for line in lines:
			(tag_name, _, tag_value) = line.partition(':')
			exif_tags[tag_name.strip()] = tag_value.strip()
		for tag in TAGS_TO_GET:
			setattr(self, tag, exif_tags[tag])	

	def _get_jpeg_checksum(self, filepath):
		'calculates the SHA512 checksum of a JPEG image'
		try:
			img = Image.open(filepath)
			cksm = hashlib.sha512()
			cksm.update(img.tostring())
			checksum = cksm.digest()
		except Exception, err:
			print "Error gettig image from file %s: %s" % (filepath, str(err))
		return checksum

	def _get_video_checksum(self, filepath):
		raise RuntimeError, "checksum generation for file %s is not possible, "\
			"not implemented yet" % filepath

	def _get_audio_checksum(self, filepath):
		raise RuntimeError, "checksum generation for file %s is not possible, "\
			"not implemented yet" % filepath

	# class methods
	@classmethod
	def _is_jpeg(CameraItem, filepath):
		'returns True is extension corresponds to image in JPEG format, elsewhere False is returned'
		if (os.path.splitext(filepath)[1].lower() in ('.jpg', '.jpeg', '.thm', '.jpe', '.jpg_original')):
			return True
		else:
			return False

	@classmethod
	def _is_image_no_metadata(CameraItem, filepath):
		'returns True is extension corresponds to image in format without data, elsewhere False is returned'
		if (os.path.splitext(filepath)[1].lower() in ('.gif', '.png')):
			return True
		else:
			return False

	@classmethod
	def _is_raw(CameraItem, filepath):
		'returns True is extension corresponds to image in RAW format, elsewhere False is returned'
		if (os.path.splitext(filepath)[1].lower() in ('.raw', '.tif', '.rw2')):
			return True
		else:
			return False

	@classmethod
	def _is_video(CameraItem, filepath):
		'returns True is extension corresponds to video, elsewhere False is returned'
		if (os.path.splitext(filepath)[1].lower() in ('.mov', '.mpg', '.avi')):
			return True
		else:
			return False

	@classmethod
	def _is_audio(CameraItem, filepath):
		'returns True is extension corresponds to audio, elsewhere False is returned'
		if (os.path.splitext(filepath)[1].lower() in ('.wav')):
			return True
		else:
			return False

	@classmethod
	def path_to_name(CameraItem, file_path):
		'returns the item name that corresponds to a certain filename'
		if not (CameraItem._is_jpeg(file_path) or
				CameraItem._is_video(file_path) or
				CameraItem._is_raw(file_path) or
				CameraItem._is_audio(file_path) or
				CameraItem._is_image_no_metadata(file_path)):
			print file_path + " is of unknown type"
			return ''
		return os.path.splitext(file_path)[0]
	
	# public methods
	def add(self, file_path):
		'adds a file to the item'
		# check that the file belongs here
		if not self._check_file(file_path):
			raise RuntimeError, file_path + " doesn't belong to item " + self.name
		# ITEM CONTENT
		# if no files in item, get content from file
		if self.content_file == "":
			self.content_file = file_path
		else:
			# if content file is a JPEG file, non-JPEG file gives content
			if self._is_jpeg(self.content_file):
				if not self._is_jpeg(file_path):
					self.content_file = file_path
				else:	
					print "the JPEG file %s cannot be added to " \
						"the item %s, it already contains the JPEG file %s" % \
						(file_path, self.name, self.tags_file)
					return
			# if content file is already a non-JPEG file, trying to add a non-JPEG file is an error
			else:
				if not self._is_jpeg(file_path):
					print "the non-JPEG file %s cannot be added " \
						"to the item %s, it already contains the content of " \
						"the non-JPEG file %s" % (file_path, self.name, self.content_file)
					return
		# ITEM TAGS
		# if JPEG file, then use its tags for the item
		if self._is_jpeg(file_path):
			if self.tags_file != "":
				raise RuntimeError, "the file %s cannot be added to the item %s, " \
					"the file %s already contains the tags of the item" % \
					(file_path, self.name, self.tags_file)
			else:
				self.tags_file = file_path
		# ITEM AUX FILES
		# if audio file, then save as auxiliar file
		if self._is_audio(file_path):
			self.aux_files.append(file_path)

	def content_checksum(self):
		'calculates the checksum of the item content'
		if self._is_jpeg(self.content):
			return self._get_jpeg_checksum(self.content)
		if self._is_raw(self.content):
			return self._get_raw_checksum(self.content)
		if self._is_video(self.content):
			return self._get_video_checksum(self.content)
		if self._is_audio(self.content):
			return self._get_audio_checksum(self.content)
		else:
			raise RuntimeError, "checksum calculation implemented only for JPEG-only items"

	def thumbnail_checksum(self):
		'calculates the checksum of the item thumbnail'
		return self._get_jpeg_checksum(self.tags_file)

	def remove(self):
		'removes the item'
		raise RuntimeError, "method remove not implemented yet in the class CameraItem"
		if self.content != "":
			os.remove(self.content)
		if self.tags_file != "":
			os.remove(self.tags_file)
		if len(self.aux_files) > 0:
			for file in self.aux_files:
				os.remove(file)

	def move(self, new_dir):
		'moves the item to the directory "new_dir"'
		raise RuntimeError, "method move not implemented yet in the class CameraItem"

# collection of items
class ItemsCollection:
	'stores items in an organize way (getting them by tag value or checksum is possible)'
	tags_to_ignore = ['Subject', 'TagsList', 'Keywords', 'HierarchicalSubject']

	def __init__(self):
		'initializes the collection'
		self.item = {}
		for tag in TAGS_TO_GET:
			setattr(self, tag, {})
		self.content_checksum = {}
		self.thumbnail_checksum = {}

	def add(self, file_path):
		'adds item to the list'
		# get the name of the item
		item_name = CameraItem.path_to_name(file_path)
		if item_name == '':
			return
		# if the item already exists, get the item
		if item_name in self.item.keys():
			item = self.item[item_name]
		# if the item doesn't exist yet, create a new one and add it to the list
		else:
			item = CameraItem(item_name)
			self.item[item_name] = item
		# add the file to the item
		item.add(file_path)

	def generate_dicts(self):
		'generate the dictionaries containing items with the same tags or checksums'
		for item_name in self.item.keys():
			item = self.item[item_name]
			for tag in TAGS_TO_GET:
				if (tag in item.exif_tags.keys()) and (tag not in ItemsCollection.tags_to_ignore):
					value_tag_photo = item.exif_tags[tag]
					tag_values = getattr(self,tag)
					if value_tag_photo in tag_values.keys():
						tag_values[value_tag_photo].append(item)
					else:
						tag_values[value_tag_photo] = [item]
			if item.content_checksum in self.content_checksum.keys():
				self.content_checksum[item.content_checksum].append(item)
			else:
				self.content_checksum[item.content_checksum] = [item]
			if item.thumbnail_checksum in self.thumbnail_checksum.keys():
				self.thumbnail_checksum[item.thumbnail_checksum].append(item)
			else:
				self.thumbnail_checksum[item.thumbnail_checksum] = [item]

	def show_dup_tags(self, tag):
		dups = []
		tag_values = getattr(self,tag)
		for tag_value in tag_values.keys():
			if len(tag_values[tag_value]) > 1:
				dups.append(tag_value)
		return dups

	def show_dup_cksms(self):
		dups = []
		for checksum in self.content_checksum.keys():
			if len(self.content_checksum) > 1:
				print checksum
				dups.append(checksum)

#
class TreeScanner:
	def __init__(self):
		self.files_to_process = []

	def _scan_subtree(self, arg, dir_path, filenames):
		for filename in filenames:
			filepath = os.path.join(dir_path, filename)
			if not (os.path.isdir(filepath) or os.path.islink(filepath)):
				if not os.path.splitext(filepath)[1] in EXTENSIONS_TO_IGNORE:
					self.files_to_process.append(filepath)

	def scan_tree(self, photostree_root):
		os.path.walk(photostree_root, self._scan_subtree, None)

class TreeProcessor:
	def __init__(self, files_to_process):
		self.files_to_process = files_to_process
		self.items = None

	def process_tree(self):
		self.items = ItemsCollection()
		n_files_to_process = len(self.files_to_process)
		i = 0
		for file in self.files_to_process:
			self.items.add(file)
			i = i + 1
			if (i % (n_files_to_process/10)) == 0:
				print "%d%% already processed" % ((i*100/ n_files_to_process) + 1)
		print "%s items result from processing the tree" % len(self.items.item.keys())
		self.items.generate_dicts()

def scan_tree(items_file):
	#photostree_root = '/home/silvavlis/Fotos'
	photostree_root = '/home/silvavlis/Pictures'
	files_list_file = '/home/silvavlis/program_org_fotos/files_list.dat'
	if os.path.exists(files_list_file) and (os.path.getsize(files_list_file) > 0):
		print "Valid files list file found, getting files from it"
		fd_tree = open(files_list_file, 'rb')
		tree= pickle.load(fd_tree)
		fd_tree.close()
	else:
		print "Valid files list file not found, generating it"
		tree = TreeScanner()
		tree.scan_tree(photostree_root)
		fd_tree = open(files_list_file, 'wb')
		pickle.dump(tree, fd_tree)
		fd_tree.close()
	print "Tree analyzed: %d files to be processed found." % len(tree.files_to_process)
	items = TreeProcessor(tree.files_to_process)
	items.process_tree()
	print "Tree processed, dumping information"
	fd_items = open(items_file,'wb')
	pickle.dump(items.items,fd_items)
	fd_items.close()

def analyze_tree(items_file):
	fd_items = open(items_file, 'rb')
	items = pickle.load(fd_items)
	fd_items.close()
	print "Photos information loaded, processing duplicates"
	print items.show_dup_cksms()

if (__name__ == '__main__'):
	items_file = '/home/silvavlis/program_org_fotos/photos_info.dat'
	if not ((os.path.exists(items_file)) and (os.path.getsize(items_file) > 0)):
		print "No valid photos information file found, scanning tree"
		scan_tree(items_file)
	print "Analyzing files"
	analyze_tree(items_file)
