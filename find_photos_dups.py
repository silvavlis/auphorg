#!/usr/bin/python

'''
Analyze every subdirectory recursively. For every file create an item with the name of the file without extension.
If an item with that name already exists, then consider it an item with sidecar. If item was of type JPEG and
new file is a video, change type to video and calculate checksum of video. If item was of type video and new
file is a JPEG, add JPEG tags to item. If item was of type JPEG and new file is a RAW, change type to RAW and 
calculate checksum of RAW image. If item was of type RAW and new file is a JPEG, add JPEG tags to item.
'''

# create exiftool request string
EXIF_TOOL = "/usr/bin/exiftool"
TAGS_TO_GET = [ 'FileName',
				'Model',
				'Software',
				'DateTimeOriginal',
				'CreateDate',
				'ImageWidth',
				'ImageHeight',
				'TagsList',
				'HierarchicalSubject',
				'Subject',
				'Keywords'
				]
EXIFTOOL_REQUEST = EXIF_TOOL + ' -s'
for tag in TAGS_TO_GET:
	EXIFTOOL_REQUEST = EXIFTOOL_REQUEST + ' -' + tag

# digital camera items
class CameraItem:
	'class that handles all kind of content (photo, video, audio) generated by a digital camera'

	# private methods
	def __init__(self, name):
		'initialize the properties of the item'
		self.name = name
		for tag in TAGS_TO_GET:
			setattr(self, tag, "")
		self.item_checksum = ""
		self.tags_file = ""
		self.content_file = ""
		self.aux_files = []

	def _check_file(self, file_path):
		'confirms that the file that wants to be added corresponds this item'
		import os.path
		file_item_name = os.path.splitext(self._files[0])[0]
		if file_item_name == self.name:
			return True
		else:
			return False

	def _is_jpeg(self, ext):
		'returns True is extension corresponds to JPEG, elsewhere False is returned'
		if (ext.lower() in ('jpg', 'jpeg')):
			return True
		else:
			return False

	def _is_raw(self, ext):
		'returns True is extension corresponds to RAW, elsewhere False is returned'
		if (ext[1:].lower() in ('raw')):
			return True
		else:
			return False

	def _get_info(self):
		'gets information of the item from the always present image'
		import subprocess, os.path

		# get the path of the image
		image_path = ''
		for file in self._files:
			if self._is_jpeg(os.path.splitext(file)[1][1:]):
				image_path = file
				break
		if image_path == '':
			raise RuntimeError, "missing image of item " + os.path.join(self.directory, self.name)
		# invoke 'exiftool' to get the information
		exif_tags = {}
		cmd = EXIFTOOL_REQUEST + ' "' + image_path + '"'
		output = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
		lines = output.read().splitlines()
		for line in lines:
			(tag_name, _, tag_value) = line.partition(':')
			exif_tags[tag_name.strip()] = tag_value.strip()
		return exif_tags

	def _get_jpeg_checksum(self, filepath):
		'calculates the SHA512 checksum of a JPEG image'
		import hashlib, Image

		try:
			img = Image.open(filepath)
			cksm = hashlib.sha512()
			cksm.update(img.tostring())
			checksum = cksm.digest()
		except Exception, err:
			print "Error gettig image from file %s: %s" % (filepath, str(err))
		return checksum

	def _get_checksum(self):
		'calculates the checksum of the item content'
		if self._is_jpeg(self.content):
			return self._get_jpeg_checksum(self.content)
		else:
			raise RuntimeError, "checksum calculation implemented only for JPEG-only items"

	# class methods
	def path_to_name(filepath):
		'returns the item name that corresponds to a certain filename'
		import os.path
		return os.path.splitext(file_path)[0]
	
	# properties
	checksum = property(self._get_checksum)

	# public methods
	def add(self, file_path):
		'adds a file to the item'
		# check that the file belongs here
		if not self._check_file(file_path):
			raise RuntimeError, file_path + " doesn't belong to item " + self.name
		# ITEM CONTENT
		# if no files in item, get content from file
		if self.content_file == "":
			self.content_file = file_path
		else:
			# if content file is a JPEG file, non-JPEG file gives content
			if self._is_jpeg(self.content_file):
				if not self._is_jpeg(file_path):
					self.content_file = file_path
				else:	
					raise RuntimeError, "the JPEG file %d cannot be added to " \
						"the item %s, it already contains the JPEG file %s" % \
						(file_path, self.name, self.tags_file)
			# if content file is already a non-JPEG file, trying to add a non-JPEG file is an error
			else:
				if not self._is_jpeg(file_path):
					raise RuntimeError, "the non-JPEG file %s cannot be added " \
						"to the item %s, it already contains the content of " \
						"the non-JPEG file %s" % (file_path, self.name, self.content)
		# ITEM TAGS
		# if JPEG file, then use its tags for the item
		if self._is_jpeg(file_path):
			if self.tags_file != "":
				raise RuntimeError, "the file %s cannot be added to the item %s, " \
					"the file %s already contains the tags of the item" % \
					(file_path, self.name, self.tags_file)
			else:
				self.tags_file = file_path

	def remove(self):
		'removes the item'
		raise RuntimeError, "method remove not implemented yet in the class CameraItem"

	def move(self, new_dir):
		'moves the item to the directory "new_dir"'
		raise RuntimeError, "method move not implemented yet in the class CameraItem"

# collection of items
class ItemsCollection:
	'stores items in an organize way (getting them by tag value or checksum is possible)'
	tags_to_ignore = ['Subject', 'TagsList', 'Keywords', 'HierarchicalSubject']

	def __init__(self):
		'initializes the collection'
		self._items = {}
		for tag in TAGS_TO_GET:
			setattr(self, tag, {})
		self.item_checksum = {}

	def add(self, file_path):
		'adds item to the list'
		# get the name of the item
		item_name = CameraItem.path_to_name(file_path)
		# if the item already exists, get the item
		if item_name in self._items.keys():
			item = self._items[item_name]
		# if the item doesn't exist yet, create a new one and add it to the list
		else:
			item = CameraItem(item_name)
			self._items[item_name] = item
		# add the file to the item
		item.add(file_path)
		# update the lists that are used to identify duplicates
		for tag in TAGS_TO_GET:
			if (tag in item.exif_tags.keys()) and (tag not in ItemsCollection.tags_to_ignore):
				value_tag_photo = item.exif_tags[tag]
				tag_values = getattr(self,tag)
				if value_tag_photo in tag_values.keys():
					tag_values[value_tag_photo].append(item)
				else:
					tag_values[value_tag_photo] = [item]
		if item.image_checksum in self.item_checksum.keys():
			self.item_checksum[item.image_checksum].append(item)
		else:
			self.item_checksum[item.image_checksum] = [item]

	def show_dup_tags(self, tag):
		dups = []
		tag_values = getattr(self,tag)
		for tag_value in tag_values.keys():
			if len(tag_values[tag_value]) > 1:
				dups.append(tag_value)
		return dups

	def show_dup_cksms(self):
		dups = []
		for checksum in self.item_checksum.keys():
			if len(self.item_checksum) > 1:
				print checksum
				dups.append(checksum)

#
class TreeProcessor:
	def __init__(self):
		self.items = ItemsCollection()
		self.jpegs = []
		self.raws = []
		self.sidecars = []

	def _is_jpeg(self, ext):
		if (ext[1:].lower() in ('jpg', 'jpeg')):
			return True
		else:
			return False

	def _is_raw(self, ext):
		if (ext[1:].lower() in ('raw')):
			return True
		else:
			return False

	def _is_sidecar(self, filepath):
		import glob, os.path
		same_name = glob.glob(os.path.splitext(filepath)[0] + '.*')
		if len(same_name) > 1:
			return True
		else:
			return False

	def _process_dir(self, arg, dir_path, filenames):
		import os.path

		for filename in filenames:
			filepath = os.path.join(dir_path, filename)
			if not os.path.isdir(filepath):
				if self._is_jpeg(os.path.splitext(filename)[1]):
					if self._is_sidecar(filepath):
						self.sidecars.append(filepath)
					else:
						self.jpegs.append(filepath)
				if self._is_raw(os.path.splitext(filename)[1]):
					self.raws.append(filepath)

	def scan_tree(self, photostree_root):
		import os.path
		os.path.walk(photostree_root, self._process_dir, None)

	def process_tree(self):
		n_jpeg_files = len(self.jpegs)
		i = 0
		for jpeg_file in self.jpegs:
			photo = PhotoFile(jpeg_file)
			self.items.add(photo)
			i = i + 1
			if (i % (n_jpeg_files/10)) == 0:
				print "%d%% already processed" % (i*100/ n_jpeg_files)

def scan_tree(photos_file):
	print "No valid photos information file found, scanning tree"
	import pickle
	photostree_root = '/home/silvavlis/Fotos'
	fd = open(photos_file,'wb')
	tree = TreeProcessor()
	tree.scan_tree(photostree_root)
	print "Tree analyzed: %d jpegs found, %d raws found and %d sidecars found." % (len(tree.jpegs), len(tree.raws), len(tree.sidecars))
	tree.process_tree()
	print "Tree processed, dumping information"
	pickle.dump(tree.photos,fd)
	fd.close()

def analyze_tree(photos_file):
	print "Photos information file found, analyzing tree"
	import pickle
	tree = pickle.load(photos_file)
	print "Photos information loaded, processing duplicates"
	print tree.show_dup_cksms()

if (__name__ == '__main__'):
	import os.path
	photos_file = '/home/silvavlis/program_org_fotos/photos_info.dat'
	if (os.path.exists(photos_file)) and (os.path.getsize(photos_file) > 0):
		analyze_tree(photos_file)
	else:
		scan_tree(photos_file)
