#!/usr/bin/python

'''
Analyze every subdirectory recursively. For every file create an item with the name of the file without extension.
If an item with that name already exists, then consider it an item with sidecar. If item was of type JPEG and
new file is a video, change type to video and calculate checksum of video. If item was of type video and new
file is a JPEG, add JPEG tags to item. If item was of type JPEG and new file is a RAW, change type to RAW and 
calculate checksum of RAW image. If item was of type RAW and new file is a JPEG, add JPEG tags to item.
'''

# create exiftool request string
EXIF_TOOL = "/usr/bin/exiftool"
TAGS_TO_GET = [ 'FileName',
				'Model',
				'Software',
				'DateTimeOriginal',
				'CreateDate',
				'ImageWidth',
				'ImageHeight',
				'TagsList',
				'HierarchicalSubject',
				'Subject',
				'Keywords'
				]
EXIFTOOL_REQUEST = EXIF_TOOL + ' -s'
for tag in TAGS_TO_GET:
	EXIFTOOL_REQUEST = EXIFTOOL_REQUEST + ' -' + tag

# digital camera items
class CameraItem:
	'class that handles all kind of content (photo, video, audio) generated by a digital camera'

	def __init__(self, files_paths):
		'default initialization'
		if not isinstance(files_paths, List):
			raise RuntimeError, 'files_paths should be a list of files'
		self._files = files_paths
		(self.directory, self.name) = self._get_item_name()
		self.item_tags = self._get_info()
		self.item_checksum = self._get_checksum()
		self.type = "photo"

	def _get_item_name(self):
		'gets the name of the item, extracted from the filenames of the item'
		import os.path
		# make sure that got content file and sidecars files
		filename_without_extension = os.path.splitext(self._files[0])[0]
		print filename_without_extension
		common_prefix_files = os.path.commonprefix(self._files)[1:]
		print common_prefix_files
		if filename_without_extension != common_prefix_files:
			raise RuntimeError, "given files don't belong together"
		# get and return the item name
		return os.path.split(common_prefix_files)[1]

	def _is_jpeg(self, ext):
		'returns True is extension corresponds to JPEG, elsewhere False is returned'
		if (ext.lower() in ('jpg', 'jpeg')):
			return True
		else:
			return False

	def _get_info(self):
		'gets information of the item from the always present image'
		import subprocess, os.path

		# get the path of the image
		image_path = ''
		for file in self._files:
			if self._is_jpeg(os.path.splitext(file)[1][1:]):
				image_path = file
				break
		if image_path == '':
			raise RuntimeError, "missing image of item " + os.path.join(self.directory, self.name)
		# invoke 'exiftool' to get the information
		exif_tags = {}
		cmd = EXIFTOOL_REQUEST + ' "' + image_path + '"'
		output = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).stdout
		lines = output.read().splitlines()
		for line in lines:
			(tag_name, _, tag_value) = line.partition(':')
			exif_tags[tag_name.strip()] = tag_value.strip()
		return exif_tags

	def _get_checksum(self):
		pass

	def remove(self):
		'removes the item'
		pass

	def move(self, new_dir):
		'moves the item to the directory "new_dir"'
		pass

class JpegPhoto(CameraItem):
	pass

class RawPhoto(CameraItem):
	pass

class Photo(CameraItem):
	'stores the information of a photo file'

	def __init__(self, photo_path):
		'initializes the object, delegating on its superclass'
		super(Photo, self).__init__([photo_path])

	def _get_photo_checksum(self):
		'calculates the SHA512 checksum of the photo'
		import hashlib, Image

		try:
			img = Image.open(self.filepath)
			cksm = hashlib.sha512()
			cksm.update(img.tostring())
			checksum = cksm.digest()
		except Exception, err:
			print "Error gettig image from file %s: %s" % (self.filepath, str(err))
		return checksum

	def _get_checksum(self):
		'get the checksum of the item, getting the checksum of the photo'
		return self._get_photo_checksum()

# collection of items
class PhotosCollection:
	'saves a collection of items'
	tags_to_ignore = ['Subject', 'TagsList', 'Keywords', 'HierarchicalSubject']

	def __init__(self):
		'initializes the collection'
		self._photos = []
		self._items = {}
		for tag in TAGS_TO_GET:
			setattr(self, tag, {})
		self.image_checksums = {}

	def add(self, file_path):
		# get the name of the component
		import os.path
		item_name = os.path.splitext(file_path)[0]
		# if the item already exists, add the file to the item and return the item
		if item_name in self._items.keys():
			item = self._items[item_name]
		# if the item doesn't exist yet, create a new item, add the file to it and return the item
		else:
			item = CameraItem(item_name)

	def add(self, photo):
		self._photos.append(photo)
		for tag in TAGS_TO_GET:
			if (tag in photo.exif_tags.keys()) and (tag not in PhotosCollection.tags_to_ignore):
				value_tag_photo = photo.exif_tags[tag]
				tag_values = getattr(self,tag)
				if value_tag_photo in tag_values.keys():
					tag_values[value_tag_photo].append(photo)
				else:
					tag_values[value_tag_photo] = [photo]
		if photo.image_checksum in self.image_checksums.keys():
			self.image_checksums[photo.image_checksum].append(photo)
		else:
			self.image_checksums[photo.image_checksum] = [photo]

	def show_dup_tags(self, tag):
		dups = []
		tag_values = getattr(self,tag)
		for tag_value in tag_values.keys():
			if len(tag_values[tag_value]) > 1:
				dups.append(tag_value)
		return dups

	def show_dup_cksms(self):
		dups = []
		for checksum in self.image_checksums.keys():
			if len(self.image_checksums) > 1:
				print checksum
				dups.append(checksum)

#
class TreeProcessor:
	def __init__(self):
		self.photos = PhotosCollection()
		self.jpegs = []
		self.raws = []
		self.sidecars = []

	def _is_jpeg(self, ext):
		if (ext[1:].lower() in ('jpg', 'jpeg')):
			return True
		else:
			return False

	def _is_raw(self, ext):
		if (ext[1:].lower() in ('raw')):
			return True
		else:
			return False

	def _is_sidecar(self, filepath):
		import glob, os.path
		same_name = glob.glob(os.path.splitext(filepath)[0] + '.*')
		if len(same_name) > 1:
			return True
		else:
			return False

	def _process_dir(self, arg, dir_path, filenames):
		import os.path

		for filename in filenames:
			filepath = os.path.join(dir_path, filename)
			if not os.path.isdir(filepath):
				if self._is_jpeg(os.path.splitext(filename)[1]):
					if self._is_sidecar(filepath):
						self.sidecars.append(filepath)
					else:
						self.jpegs.append(filepath)
				if self._is_raw(os.path.splitext(filename)[1]):
					self.raws.append(filepath)

	def scan_tree(self, photostree_root):
		import os.path
		os.path.walk(photostree_root, self._process_dir, None)

	def process_tree(self):
		n_jpeg_files = len(self.jpegs)
		i = 0
		for jpeg_file in self.jpegs:
			photo = PhotoFile(jpeg_file)
			self.photos.add(photo)
			i = i + 1
			if (i % (n_jpeg_files/10)) == 0:
				print "%d%% already processed" % (i*100/ n_jpeg_files)

def scan_tree(photos_file):
	print "No valid photos information file found, scanning tree"
	import pickle
	photostree_root = '/home/silvavlis/Fotos'
	fd = open(photos_file,'wb')
	tree = TreeProcessor()
	tree.scan_tree(photostree_root)
	print "Tree analyzed: %d jpegs found, %d raws found and %d sidecars found." % (len(tree.jpegs), len(tree.raws), len(tree.sidecars))
	tree.process_tree()
	print "Tree processed, dumping information"
	pickle.dump(tree.photos,fd)
	fd.close()

def analyze_tree(photos_file):
	print "Photos information file found, analyzing tree"
	import pickle
	tree = pickle.load(photos_file)
	print "Photos information loaded, processing duplicates"
	print tree.show_dup_cksms()

if (__name__ == '__main__'):
	import os.path
	photos_file = '/home/silvavlis/program_org_fotos/photos_info.dat'
	if (os.path.exists(photos_file)) and (os.path.getsize(photos_file) > 0):
		analyze_tree(photos_file)
	else:
		scan_tree(photos_file)
